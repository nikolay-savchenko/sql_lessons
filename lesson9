-- В базе данных shop и sample присутствуют одни и те же таблицы, учебной базы данных. 
-- Переместите запись id = 1 из таблицы shop.users в таблицу sample.users. Используйте транзакции.
drop database shop;
select* from users;
select* from accounts;
select* from products;
select* from catalogs;

show tables;


start transaction;
insert into accounts select 5, id, null, created_at, updated_at from users where id=1;
delete from users where id=1;
rollback;
commit;

-- Создайте представление, которое выводит название name товарной позиции из таблицы products
--  и соответствующее название каталога name из таблицы catalogs.


create view tbl (product_name, cat_name)
as 
select pro_n, name from (select products.name as pro_n, products.catalog_id, catalogs.id, catalogs.name from products
join catalogs 
on products.catalog_id=catalogs.id) as t;

select * from tbl;



-- Создайте двух пользователей которые имеют доступ к базе данных shop. 
-- Первому пользователю shop_read должны быть доступны только запросы на чтение данных, 
-- второму пользователю shop — любые операции в пределах базы данных shop.


GRANT SELECT ON shop.* TO 'shop_read'@'localhost' IDENTIFIED BY '12345678';
GRANT ALL ON shop.* TO 'shop'@'localhost' IDENTIFIED BY '12345678'; 

-- (по желанию) Пусть имеется таблица accounts содержащая три столбца id, name, password, содержащие первичный ключ, 
-- имя пользователя и его пароль. Создайте представление username таблицы accounts, предоставляющий доступ к столбца id и name. 
-- Создайте пользователя user_read, который бы не имел доступа к таблице accounts, однако, 
-- мог бы извлекать записи из представления username.

DROP TABLE IF EXISTS accounts;
CREATE TABLE user (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) COMMENT 'Имя пользователя',
    password VARCHAR(255) COMMENT 'Пароль'
) COMMENT = 'Пользователи';
INSERT INTO accounts (name, password) VALUES
    ('A', '123'),
    ('B', '1234'),
    ('C', '12345');
CREATE OR REPLACE VIEW username AS SELECT id, name FROM accounts;
GRANT SELECT ON shop.username TO 'user_read'@'localhost' IDENTIFIED BY '12345678';
exit

SELECT host, user FROM mysql.user;
DROP USER 'shop'@'localhost', 'shop_read'@'localhost', 'user_read'@'localhost'; 


-- Создайте хранимую функцию hello(), которая будет возвращать приветствие, в зависимости от текущего времени суток. 
-- С 6:00 до 12:00 функция должна возвращать фразу "Доброе утро", с 12:00 до 18:00 функция должна возвращать фразу "Добрый день", 
-- с 18:00 до 00:00 — "Добрый вечер", с 00:00 до 6:00 — "Доброй ночи".

DELIMITER //

SET GLOBAL log_bin_trust_function_creators = 1;

CREATE FUNCTION hello()
RETURNS TINYTEXT
BEGIN
	DECLARE hour INT;
	SET hour = HOUR(NOW());
	CASE
		WHEN hour BETWEEN 0 AND 5 THEN 
			RETURN "ДОБРОЙ НОЧИ";
		WHEN hour BETWEEN 6 AND 11 THEN 
			RETURN "ДОБРОЕ УТРО";
		WHEN hour BETWEEN 12 AND 17 THEN 
			RETURN "ДОБРЫЙ ДЕНЬ";
		WHEN hour BETWEEN 18 AND 23 THEN 
			RETURN "ДОБРЫЙ ВЕЧЕР";
		END CASE;
END// 

SELECT HELLO();

-- В таблице products есть два текстовых поля: name с названием товара и description с его описанием. 
-- Допустимо присутствие обоих полей или одно из них. Ситуация, когда оба поля принимают неопределенное значение NULL неприемлема. 
-- Используя триггеры, добейтесь того, чтобы одно из этих полей или оба поля были заполнены. 
-- При попытке присвоить полям NULL-значение необходимо отменить операцию.


DELIMITER //

CREATE TRIGGER validate_name_description_insert BEFORE INSERT ON products
FOR EACH ROW BEGIN
  IF NEW.name IS NULL AND NEW.description IS NULL THEN
    SIGNAL SQLSTATE '45000'
    SET MESSAGE_TEXT = 'Both name and description are NULL';
  END IF;
END//

INSERT INTO products
  (name, description, price, catalog_id)
VALUES
  (NULL, NULL, 9360.00, 2)//

INSERT INTO products
  (name, description, price, catalog_id)
VALUES
  ('ASUS PRIME Z370-P', 'HDMI, SATA3, PCI Express 3.0,, USB 3.1', 9360.00, 2)//

INSERT INTO products
  (name, description, price, catalog_id)
VALUES
  (NULL, 'HDMI, SATA3, PCI Express 3.0,, USB 3.1', 9360.00, 2)//

CREATE TRIGGER validate_name_description_update BEFORE UPDATE ON products
FOR EACH ROW BEGIN
  IF NEW.name IS NULL AND NEW.description IS NULL THEN
    SIGNAL SQLSTATE '45000'
    SET MESSAGE_TEXT = 'Both name and description are NULL';
  END IF;
END//


